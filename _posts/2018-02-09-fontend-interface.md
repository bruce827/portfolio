---
layout: post
title: "前后端接口文档规范"
date: 2015-02-09 19:33:48
image: '/assets/img/dica-rapida-2/main.png'
description: '前后台分离势在必行，'
main-class: 'html'
color: '#EB7728'
tags:
- UI
- 模板
- 前端
categories:
twitter_text: 'Aprenda a usar as meta tags sociais.'
introduction: ""
---

## 写在前面
本文仅适合于前后台分离的项目，使用前提是在项目计划初期要先进行接口文档约定。  
对于目前我所经历的所有项目来说，前后台分离一定要尽最大可能让开发人员进行集中开发，因为如果是前后台异地开发的话，到联调或接口更改时简直就是噩梦，就更不用提跨部门或团队的沟通了，我曾经在一个项目中仔细的计算了一下，从需求评审到冒烟测试这段时间中，仅仅是因为异地开发这一点，开发人员的沟通时间成本是3-4小时/天，而如果是集中开发，每天的沟通不会超过一个小时。
## 为何一定要前后端分离
[WEB开发模式](http://blog.jobbole.com/65509/)经历了一代又一代,从最早的内容驱动、后端渲染的模式已经过渡到微服务、[组件化](http://blog.jobbole.com/56161/)的快速迭代，自动化部署的开发模式。
* 前端开发重度依赖开发环境，开发效率低。
这种架构下，前后端协作有两种模式：
一种是前端写demo，写好后，让后端去套模板 。
淘宝早期包括现在依旧有大量业务线是这种模式。
好处很明显，demo 可以本地开发，很高效。
不足是还需要后端套模板，有可能套错，套完后还需要前端确定，来回沟通调整的成本比较大。
另一种协作模式是前端负责浏览器端的所有开发和服务器端的 View 层模板开发，支付宝是这种模式。
好处是 UI 相关的代码都是前端去写就好，后端不用太关注，不足就是前端开发重度绑定后端环境，环境成为影响前端开发效率的重要因素。
* 前后端职责依旧纠缠不清。
页面逻辑，跳转错误，浏览器兼容性问题，脚本错误，页面样式等问题，全部由前端工程师来负责。
接口数据出错，数据没有提交成功，应答超时等问题，全部由后端工程师来解决。
双方互不干扰，前端与后端是相亲相爱的一家人。
> 说起来简单，真正的项目中其实踢皮球的现象依然广为存在，想要根本解决还是要强有力的管理决策  

* 对前端发挥的局限。
性能优化如果只在前端做空间非常有限，于是我们经常需要后端合作才能碰撞出火花，但由于后端框架限制，我们很难使用Comet、Bigpipe等技术方案来优化性能。   
* 
总上所述，就跟为什麽要代码重构一样
* 关注点分离
* 职责分离
* 对的人做对的事
* 更好的共建模式
* 快速的反应变化  

## 如何做分离
前端由于其本身技术的局限，目前还是没有办法做数据、菜单、按钮等权限的业务逻辑，即使有一些解决方案也是会有一些安全问题。所以目前通用的做法还是把业务逻辑放在后端来写。那么本着*业务逻辑端提供数据结构*的开发原则，数据结构应该又后端来提供。
接口约定不能仅仅依赖于SVN、GIT、google doc等工具，最好的方案是依赖于第三方接口平台，目前三个主流的API接口平台；
- RAML
- Swagger
- Blueprint  

当然还有很多这样的平台，这里没接触过所以不推荐了，
对于这三个平台的比较网上有很多，这里我个人的看法是，如果涉及到跨公司之间的开发，比如数据库和后台是一个公司，前台是一个公司那么推荐使用RAML，如果是一个团队开发，推荐使用Swagger，如果开发团队新人较多，推荐使用Blueprint。
### 前端职责
* 接收数据，返回数据
* 处理交互逻辑
* 渲染数据结构并且适配主流浏览器内核  

### 后端职责
* 提供数据（包括分页）
* 处理包括数据、按钮、菜单权限的业务逻辑
* 处理大数据量高并发等服务支撑  

## 一般开发流程
### 老的CMMI发模式和弊端
1. 产品经历/领导/客户提出需求
2. UI做出设计图
3. 前端工程师做html页面
4. 后端工程师将html页面套成jsp页面（前后端强依赖，后端必须要等前端的html做好才能套jsp。如果html发生变更，就更痛了，开发效率低）
5. 集成出现问题
6. 前端返工
7. 后端返工
8. 二次集成
9. 集成成功
10. 交付  

### 现代开发模式
0. 产品经历/领导/客户提出需求。
1. UI设计出设计稿。
1. 后端编写和维护接口文档，在 API 变化时更新接口文档。
2. 后端根据接口文档进行接口开发。
3. 前端根据接口文档进行开发 + Mock平台。
4. 开发完成后联调和提交测试。
这里面我们为了提高开发效率，我们都是采取前后台并行开发，那么就涉及到在开发阶段有需求变更的情况，**既然需求变更无法避免，那么最小的变更成本就是版本迭代**。    

这里需要注意的是，前后端分离也有自己本身的局限性，但是总体来说会比老的开发模式好很多。前后端分离的最大好处就是分担了开发的压力，原来我们估工作量时候，差分功能很可能会估到3天以上的工作量，这在项目管理方面简直就是噩梦，而现在大多数功能都可以很容易拆分成2-3天的节点。
## 接口模板规范（通用版）

### 基本原则
* 接口返回数据即显示：前端仅做渲染逻辑处理。
* 渲染逻辑禁止跨多个接口调用。
* 前端关注交互、渲染逻辑，尽量避免业务逻辑处理的出现。
* 请求响应传输数据格式：JSON，JSON数据尽量简单轻量，避免多级JSON的出现。  

### 基本格式
#### 请求格式
GET请求、POST请求==必须包含key为body的入参，所有请求数据包装为JSON格式，并存放到入参body中==，示例如下：

GET请求：
{% highlight json %}
xxx/login?body={
    "username":"admin",
    "password":"123456",
    "captcha":"scfd",
    "rememberMe":1
}
{% endhighlight %}
POST请求：
{% highlight json %}
body:{
    "username":"admin",
    "password":"123456", 
    "captcha":"scfd",
    "rememberMe":1
},
{% endhighlight %}
#### 响应基本格式
{% highlight json %}
{
    code: 200,
    data: {
        message: "success"
    }
}
{% endhighlight %}
code : 请求处理状态:
- 200: 请求处理成功
- 500: 请求处理失败
- 401: 请求未认证，跳转登录页
- 406: 请求未授权，跳转未授权提示页  

data.message: 请求处理消息:
- code=200 且 data.message="success": 请求处理成功  
- code=200 且 data.message!="success": 请求处理成功,普通消息提示：messag内容  
- code=500: 请求处理失败，警告消息提示：message内容
### 响应实体格式
{% highlight json %}
{
    code: 200,
    data: {
        message: "success",
        entity: {
            id: 1,
            name: "XXX",
            code: "XXX"
        }
    }
}
{% endhighlight %}
data.entity: 响应返回的实体数据。
### 响应列表格式
data.list:返回列表
### 响应分页格式
{% highlight json %}
{
    code: 200,
    data: {
        recordCount: 2,
        message: "success",
        totalCount: 2,
        pageNo: 1,
        pageSize: 10,
        list: [
            {
                id: 1,
                name: "XXX",
                code: "H001"
            },
            {
                id: 2,
                name: "XXX",
                code: "H001"
            } ],
        totalPage: 1
    }
}
{% endhighlight %}

- data.recordCount: 当前页记录数
- data.totalCount: 总记录数
- data.pageNo: 当前页码
- data.pageSize: 每页大小
- data.totalPage: 总页数  

### 特殊内容规范
*  下拉框、复选框、单选框
由后端接口统一逻辑判定是否选中，通过isSelect标示是否选中，示例如下：
{% highlight json %}
{
    code: 200,
    data: {
        message: "success",
        list: [{
            id: 1,
            name: "XXX",
            code: "XXX",
            isSelect: 1
        }, {
            id: 1,
            name: "XXX",
            code: "XXX",
            isSelect: 0
        }]
    }
}
{% endhighlight %}
禁止下拉框、复选框、单选框判定选中逻辑由前端来处理，统一由后端逻辑判定选中返回给前端展示。
*  Boolean类型
关于Boolean类型，JSON数据传输中一律使用1/0来标示，1为是/True，0为否/False。
* 日期类型
关于日期类型，JSON数据传输中一律使用字符串，具体日期格式因业务而定。

## 前后端更高效的协作
### 尽量避免后端模板渲染
web 应用的渲染方式分为服务器端渲染和客户端渲染，当下比较推荐的方式是客户端渲染，数据使用全 ajax 的方式进行交互。
除非在一些不得不使用服务器端渲染的情况下（如门户、电商等），应当尽量使用客户端渲染，因为客户端渲染更能使前后端分离（项目分离、代码解耦、协作分离、职责分离等），也能更好的做本地接口模拟开发，提升开发效率。
即使用服务器端渲染，在技术支持的条件下，可以使用 node 中间层（由前端人员开发），代替传统的后端模板渲染，这样可以使后端与前端完全解耦，后端与前端只有数据上的往来。
### 尽量避免大量的线上调试
做好本地接口模拟开发（包括后端模板渲染），避免大量的线上调试，因为线上调试很不方便，也很费事，并且每次更新代码，都需要重新构建，然后同步到服务器。
所以做好本地接口模拟开发，只要程序在本地运行是没问题的，一般线上就不会有太大的问题，这样就能大幅降低调试工作量，提升开发效率。
### 本地接口模拟开发
本地接口模拟就是在本地模拟一个与服务器差不多的环境，能够提供数据所需的接口，进行错误模拟处理等等。
本地接口模拟开发的意义就在于能够在本地完成几乎所有的开发与调试，尽量减少线上的调试，提高开发效率。
一些常用库：
- browser-sync(https://github.com/BrowserSync/browser-sync)：能让浏览器实时、快速响应文件更改（ html、 js、css、 sass、 less 等）并自动刷新页面，并且可以同时在PC、平板、手机等设备下进行调试。
-webpack-dev-middleware(https://github.com/webpack/webpack-dev-middleware)：A development middleware for webpack。
- webpack-hot-middleware(https://github.com/webpack-contrib/webpack-hot-middleware)：热更新本地开发浏览器服务。
另外，本地接口模拟开发需要后端开发人员有规范的接口文档。  
### 去缓存
前端需要做好去客户端缓存的功能，保证用户始终都是使用的最新资源，不会因为因为缓存的问题而出现 bug。
传统的去缓存是在静态资源 url 上加上版本号或者时间戳，不过因为构建工具的出现以及一些浏览器已经不支持这种方式了的缘故，这种方式已经是过去时了。
现在去缓存是将文件 hash 化命名，只要文件变动，文件名就会不一样，以此才能彻底的去缓存。如果使用 webpack 进行打包，会自动将所有文件进行 hash 化命名。
### 做好错误处理
前端与后端都需要各自做好错误处理，以便发生错误能够有友好的提示，也能在用户反馈时快速准确定位错误来源和原因。
一般前端的错误分为：
脚本运行错误： js 脚本错误，找到堆栈信息，然后解决
接口错误：服务器报错、数据返回不对、没有响应数据、超时等
而接口错误分为：
状态码错误（状态码非 2XX）：服务器报错、超时等
数据错误：没有响应数据、数据格式不对、数据内容不对
### 移动端远程调试、vConsole、TBS Studio
因为移动端的开发无法像 pc 端开发一样使用 Chrome 的开发者调试工具，所以调试移动端需要一些额外的技巧。
移动端应用一般都运行在微信浏览器中、 webview 中、手机浏览器中。
1. 远程调试（Remote Debugging）
远程调试就是通过 USB 连接、端口转发、搭建代理等方式，将一个设备的 web 页面映射到另一个设备上，比如将手机的 webview 映射到 pc 上，达到调试的目的。
移动端 web 应用调试难题从一开始就有，不过后来浏览器厂商基本都推出自己的远程调试工具来解决这个问题，包括 OperaMobile、 iOSSafari、 ChromeforAndroid、UC 浏览器等，另外还有一些第三方开发的远程调试工具，比如 weinre(http://people.apache.org/~pmuellr/weinre/docs/1.x/1.5.0/) 等。
以 Android 为例，可以将 webview、 ChromeforAndroid 中的页面映射到 pc 端的 ChromeDevTools，然后就可以在 pc 端调试移动端的页面了。
2. vConsole
一个轻量、可拓展、针对手机网页的前端开发者调试面板（ chrome 开发者工具的便利实现）。
这个是内嵌的页面当中的便捷调试器，基本上能够满足一般的需要远程调试的页面。
github：https://github.com/Tencent/vConsole
demo：https://wechatfe.github.io/vconsole/demo.html
3. TBS Studio
因为微信浏览器是定制的浏览器，一般的远程调试方式都不可用，需要配合特定的工具，如微信开发者工具。
TBS Studio(https://x5.tencent.com/tbs/guide.html) 是另一个可以像 Chrome 一样调试远程微信浏览器页面的强大工具。

## 对于小白前端的联调建议
> 我们通常意义上的联调是指双方在依照接口文档各自开发完功能并且测试过后的后续url切换与调试等步骤，但是根据实际项目情况的不同，有时候前端开发者可能会在联调之前才会拿到接口文档的最终版（可能里面还会有错误），如果接口有变化（一般情况下都会有）那么前端开发就会面临着边开发边联调的境地。

### 基本的联调流程
1. 先依照文档的描述用接口工具测一下接口是否好用，如果是404就没必要近项目里面调整了。
2. 如果有登录先处理登录接口，里面可能会有些数据需要保存在浏览器中。
    * 调用成功后查看是否跳窗成功
    * 查看浏览器本地是否有想要的数据
3. 打断点，看传参
    * 在请求API的最后步把参数打印出来，与文档进行比对（debugger）
    * 请求后看返回值（debugger）
    * 与文档核对返回信息，看是否达到预期
    * 进行自己前台的逻辑（如果数据结构没有改变的话，应该不用改）
    * 测试添加接口时候要先看看添加页面的数据是否已经加完ok，再进行表单填写验证添加接口
    * 提交表单的参数一定要细心，一个一个的与文档对一遍
    * 删除前端为了mock数据时候写的代码，放开刷新操作
4. 看数据，沟通，做处理
    * 日期时间处理：除非前台有特殊的展现形式，不然都是文档统一规定好的
    * 空值：有些字段如果为空到底是传什么数据格式，是null、[]还是空字符串要提前约定好
    * 图片上传接口：检查返回数据格式，通常情况下返回的只有一份url地址
    * 码表：在项目初期就要确定下来码表的维护职责，如果后台没有给接口则前台在联调数据的时候要特别注意
    * 表单校验：要有基本的校验，先校验必填的字段，保证提交的步骤没有问题，在去核对数

### 给新手前端的联调技巧
* 如果没有特殊原因，尽量不要同时联调多个接口，尤其是同一模块的接口
* 如果接口文档的传参变了，在最大情况下保留页面相关的原有代码不变，仅在请求的前一步做映射
* 任何的接口联调都是基于文档，文档由业务逻辑方（后台）进行维护
* 对于有表单的页面，在联调时候可以适当延长计划时间
* 需要调用用户信息的接口在联调时候最好选择隐私模式或者每次记得清空缓存
* 每个模块、每个系统联调完成后要有回归测试

